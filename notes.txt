**** BUILDING A PHASER GAME WITH PHYSICS *******

Figuring out the rules of a video game is a one of the joys of starting a new game. 
- we wonder how fast our character can go, or how high it jumps , or what happens when it touches an enemy sprite.
- as a game developer, implementing these rules is about deciding the physics of our game.

- the physics of a game determines how GameObjects interact with the game world. 

((( Phaser provides built-in physics plugins to create a game with set rules & interactions )));

we make use of:
this.physics.add.sprite() and have our sprite affected by physics!
=> in this case the sprite will feel the effects of gravity.
- the method  `this.physics.add.sprite()` takes 3 arguments:
  a) -> the first argument sets the x-coordinate of the sprite's center.
  b) -> second argument sets the y-coordinate of the sprite's center.
  c) -> third argument is the key of the image loaded in the preload() function.

  ********** IMPLEMENTING PHYSICS ***********

- To implement gravity we make use of a `physics plugin` which decides how GameObjects interact with each other.
- the plugin we're going to use is Phaser's Arcade physics plugin - this plugin is great for adding gravity to the game & detecting collisions.
=> to add the Arcade physics plugin to our config object, we need to add a physics property & provide additional specifications in its value: 

   e.g const config = {
       // ......
       physics: {
           default: 'arcade',
           arcade: {
               gravity: { y: 300 },
               debug: true
           }
       }
   }

   *explanation* => the physics property, the object has two keys, `default` & `arcade`:
                 a) `default` has a value of 'arcade' which tells Phaser to use the Arcade physics plugin.
                 b) `arcade` is another object that contains details about how we want the Arcad physics to work. The object has two keys:
                    -> gravity ~ which is set to { y: 300 } to assign a downward gravity.
                      - the value 300 is based on personal preference, the higher the number, the stronger the effect of gravity is.
                    -> debug ~ with a value of true to see the outline of objects in our game & the velocity.

NB * -> when we call this.physics.add.sprite(), we're telling Phaser's physics plugin to create our sprite for us & have this sprite follow the physics the game.

************* adding static groups ***********

- we need to get the player sprite to land on some steady ground.
- we first need to create a ground platform!
- this gorund platform will not be affected by gravity but we want it to interact with the player sprite.
- we can't use this.add.image() like we do for our background image since images aren't affected by physics and don't interact with GameObjects.

=> what we need is this.physics.add.staticGroup() to create a Group object which keeps track of our platforms.
=> Group objects are used to create and maintain sprites in a group.
-> in this case we can use this Group object to create additional platforms.

e.g function create() {
    const platforms = this.physics.add.staticGroup();
    platforms.create(320, 350, 'platform');
}

** explanation *** => we've created a static group Object & saved it to the platforms variable.
                   => Our platforms won't be affected by the game's gravity.
                   -> then we call platforms.create() with 3 arguments:
                     a) - the first argument is the x-coordinate of the sprite's center
                     b) - the second argument is the y-coordinate of the sprite's center.
                     c) - the last argument is the ky of the sprite's image.


***** DETECTING COLLISIONS *****

- Remember our physics plugin determines how GameObjects interact.
- The way to decide these interactions is to create a Collider object that checks if two GameObjects bump into each other.

=> to set a collider object we need to call this.physics.add.collider().
-> the .collider() method takes three arguments ( the last one argument is optional).
-> the first two arguments are the GameObjects ( or Group objects ) that collide.

e.g function create() {
    const player = this.physics.add.sprite(100, 100, 'player');
    const platform = this.physics.add.sprite(100, 500, 'platform');

    this.physics.add.collider(player, platform);
}


NB** => now, the player & the platform objects don't overlap when they bump into each other.
-> while we're on the topic of collisions, we can call the .setCollideWorldBounds(true) for GameObjects that we want to stay inside the screen of the game.

e.g callign: player.setCollideWorldBounds(true) will make it so the player sprite can't fall off the screen;

***** ADDING CONTROLS & VELOCITY *****


