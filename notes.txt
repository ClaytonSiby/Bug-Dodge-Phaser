**** BUILDING A PHASER GAME WITH PHYSICS *******

Figuring out the rules of a video game is a one of the joys of starting a new game. 
- we wonder how fast our character can go, or how high it jumps , or what happens when it touches an enemy sprite.
- as a game developer, implementing these rules is about deciding the physics of our game.

- the physics of a game determines how GameObjects interact with the game world. 

((( Phaser provides built-in physics plugins to create a game with set rules & interactions )));

we make use of:
this.physics.add.sprite() and have our sprite affected by physics!
=> in this case the sprite will feel the effects of gravity.
- the method  `this.physics.add.sprite()` takes 3 arguments:
  a) -> the first argument sets the x-coordinate of the sprite's center.
  b) -> second argument sets the y-coordinate of the sprite's center.
  c) -> third argument is the key of the image loaded in the preload() function.

  ********** IMPLEMENTING PHYSICS ***********

- To implement gravity we make use of a `physics plugin` which decides how GameObjects interact with each other.
- the plugin we're going to use is Phaser's Arcade physics plugin - this plugin is great for adding gravity to the game & detecting collisions.
=> to add the Arcade physics plugin to our config object, we need to add a physics property & provide additional specifications in its value: 

   e.g const config = {
       // ......
       physics: {
           default: 'arcade',
           arcade: {
               gravity: { y: 300 },
               debug: true
           }
       }
   }

   *explanation* => the physics property, the object has two keys, `default` & `arcade`:
                 a) `default` has a value of 'arcade' which tells Phaser to use the Arcade physics plugin.
                 b) `arcade` is another object that contains details about how we want the Arcade physics to work. The object has two keys:
                    -> gravity ~ which is set to { y: 300 } to assign a downward gravity.
                      - the value 300 is based on personal preference, the higher the number, the stronger the effect of gravity is.
                    -> debug ~ with a value of true to see the outline of objects in our game & the velocity.

NB * -> when we call this.physics.add.sprite(), we're telling Phaser's physics plugin to create our sprite for us & have this sprite follow the physics the game.

************* adding static groups ***********

- we need to get the player sprite to land on some steady ground.
- we first need to create a ground platform!
- this ground platform will not be affected by gravity but we want it to interact with the player sprite.
- we can't use this.add.image() like we do for our background image since images aren't affected by physics and don't interact with GameObjects.

=> what we need is this.physics.add.staticGroup() to create a Group object which keeps track of our platforms.
=> Group objects are used to create and maintain sprites in a group.
-> in this case we can use this Group object to create additional platforms.

e.g function create() {
    const platforms = this.physics.add.staticGroup();
    platforms.create(320, 350, 'platform');
}

** explanation *** => we've created a static group Object & saved it to the platforms variable.
                   => Our platforms won't be affected by the game's gravity.
                   -> then we call platforms.create() with 3 arguments:
                     a) - the first argument is the x-coordinate of the sprite's center
                     b) - the second argument is the y-coordinate of the sprite's center.
                     c) - the last argument is the ky of the sprite's image.


***** DETECTING COLLISIONS *****

- Remember our physics plugin determines how GameObjects interact.
- The way to decide these interactions is to create a Collider object that checks if two GameObjects bump into each other.

=> to set a collider object we need to call this.physics.add.collider().
-> the .collider() method takes three arguments ( the last one argument is optional).
-> the first two arguments are the GameObjects ( or Group objects ) that collide.

e.g function create() {
    const player = this.physics.add.sprite(100, 100, 'player');
    const platform = this.physics.add.sprite(100, 500, 'platform');

    this.physics.add.collider(player, platform);
}


NB** => now, the player & the platform objects don't overlap when they bump into each other.
-> while we're on the topic of collisions, we can call the .setCollideWorldBounds(true) for GameObjects that we want to stay inside the screen of the game.

e.g callign: player.setCollideWorldBounds(true) will make it so the player sprite can't fall off the screen;

***** ADDING CONTROLS & VELOCITY *****

- One way we can implement controls is by using Phaser's `this.input.keyboard.createCursorKeys()` method to create a useful object for keyboard inputs.
- the created object has properties:
  ( up, down, left, right, space, and shift ). -> these are directly related to the keyboard keys.
  -> we can also acces the .isDown property to the key to see if it is pressed.
- If the key is pressed, we can change the horizontal velocity of the GameObject by using the .setVelocityX() method.

e.g function create() {
    gameState.cursors = this.input.keyboard.createCursorKeys();
  }
    
  function update() {
    if(gameState.cursors.left.isDown) {
      heroSprite.setVelocityX(-160);
    } else if(gameState.cursors.right.isDown) {
      heroSprite.setVelocityX(160);
    } else {
      heroSprite.setVelocityX(0);
    }
  }

************ ADDING ENEMIES ********** 

- Unlike the player sprite, we probably want multiple enemies to triumph over.
- & unlike the platform, we should have physics affect them.
- Phaser has a handy method for us, this.physics.add.group() which returns a Group object that we can use to organize multiple enemy sprites. e.g:

  function create() {
    const enemies = this.physics.add.group();
    enemies.create(320, 10, 'enemy');
  }


-> from the example we called `this.physics.add.group() and assigned it to a variable, `enemies`.
-> then we call enemies.create(320, 10, 'enemy') t0 create one sprite centered at the coordinates ( 320, 10) using the `enemy` key.

NB -. with our current code, we know that our enemy will always appear at the coordinate ( 320, 10).
-> we can randomize where this enemy's x-coordinate using Math.random() & multiply that value by the width of the screen.

=> when we multiply the value from Math.random() with width of the screen ( in pixels), we get a value that is between from 0 ( left-hand side) to the width of the game ( right-hand side).
=> the product is a random x-coordinate that is always on the screen.

e.g function create() {
   const enemies = this.physics.add.group();
   const xCoordinate = Math.random() * 450;

   enemies.create(xCoordinate, 10, 'enemy' );
}

*=> since we want to create multiple enemy sprites, we can use a function to house the logic for enemy creation:

e.g function create() {
   const enemies = this.physics.add.group();
   function generateEnemy () {
     const xCoordinate = Math.random() * 450;
     enemies.create(xCoordinate, 10, 'enemy' );
   }
}

-> with the example above, we can create an enemy sprite everytime we call generateEnemy();

